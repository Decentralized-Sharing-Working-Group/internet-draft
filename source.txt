INTERNET DRAFT                                      Michiel B. de Jong
Document: draft-dejong-decentralizedsharing-00           (independent)
                                                         Paul Tran-Van
Intended Status: Informational                            (Cozy Cloud)
Expires: ** December 2015                                  ** May 2015


                         Decentralized Sharing

Abstract

This draft describes the steps and challenges of sharing documents
between persons, using internet-connected servers. We investigate the
situation where a document exists on a server to which the sender has
access through some software application, but the recipient(s) don't.
All recipient(s) do, however, have access to software applications that
run on least one other server.

We discuss existing and proposed methods for the sender to initiate the
communication, for each recipient to become aware of the sender's intent
to share a document, for each recipient to access the document directly,
for the document contents to be transmitted to server(s) to which the
recipient(s) have access, for the sender to make and announce changes in
the document after it was initially sent, and for the recipient(s) to
communicate comments and proposed changes to the document back to the
sender's server.

We also discuss how semantics of the document may be communicated,
and how versioning conflicts may then in some cases be resolved
programmatically. Given that users of personal servers don't all run
the same compatible software on their server, the sending application
needs to discover which application-level protocols are supported by the
receiving application.


Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on ** December 2015.


Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors. All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.


Table of Contents

   1. Introduction...................................................3
   2. Initiate sharing process.......................................4
   3. Recipient selection............................................5
   4. Recipient notification.........................................5
   5. Human access...................................................7
   6. Machine access ................................................*
   7. Publishing edits...............................................*
   8. Comments and write access......................................*
   9. Real-time collaboration........................................*
   10. Listing and revoking access...................................*
   11. Data domains..................................................*
   12. Security Considerations.......................................*
   13. IANA Considerations...........................................*
   14. Acknowledgements..............................................*
   15. References....................................................*
   15.1. Normative References........................................*
   15.2. Informative References......................................*
   16. Authors' addresses............................................*




1.  Introduction

When we say a sender 'shares' a document with some recipient(s),
we primarily mean the sender makes that document available for the
recipient(s) to consume, but not to others. Additionally, the sender
may send updated versions of the document after it was sent, and
recipient(s) may reply with comments and propose changes to the
document. The sender may decide to make such updates accessible to all
original recipient(s) or not. When we say 'document', we mean a string
of data which encodes some human-readable content in some data format.

There are several protocols for sending a document from one server to
another. For instance, the sender may use an email client to connect
to her server via the [IMAP] protocol, or use a web browser to connect
to her server via the [HTTPS] protocol ("webmail"), to instruct her
server to forward an existing mail message from her server to one or
more recipients, identified by their email addresses, after which the
mailserver application running on her server can deliver the document to
the recipient's server using the [SMTP] protocol. The recipient may then
access the document from his server over the [POP], [IMAP], or [HTTPS]
protocol.

However, many software applications which people use nowadays to access
their documents, do not implement the SMTP, IMAP, or POP protocol
(often due to the complexity of dealing with email spam). Also, there
is no commonly supported programmatic way for the sender to update
documents after they have been sent over SMTP, nor for the recipient(s)
to reply with proposed changes. Rather than proposing such a versioning
protocol on top of SMTP, we investigate how currently existing software
applications implement decentralized document sharing in practice, and
where these common practices could be improved and extended.

Some software applications allow sharing documents between users who
have access to the same server (we could call this centralized sharing),
and some also implement application-specific protocols that allow
their users to share documents with other users of the same software.
This leads to a dispersion of efforts between personal server software
projects.

Many software applications do allow sharing documents publically, for
instance by making them accessible over [HTTPS]. There are many ways to
restrict access to documents that are published that way, but this does
not solve the question of how recipient(s) get notified in the first
place that (and how) they have access to such a document.

There is no consensus yet on how to share documents privately over the
internet, in such a way that recipient(s) are notified, but other people
cannot retrieve the document, nor discover its existence.

This draft does not propose one universal solution, but rather lists
what puzzle pieces we are aware of, and what options may exist to put
them together. In general, we are interested in the case where there may
be more than one recipient, and where each recipient may have access to
more than one server (but not to the sender's server). But for clarity
of discussion we will at this point look at a simpler case.

We introduce Alice, who wants to share one document with Bob. Alice
and Bob both have a personal server, which they access to over a
web interface, that's to say, using a web browser that connects to
their server over HTTPS. This interface displays information in a
human-readable way, and allows humans to easily send commands using for
instance their web browser's point-and-click gestures.

We assume there are multiple documents on Alice's server, and the web
interface visualizes these for her. We make no assumptions at this point
about the content of these documents; they can be text, hypertext, sound,
image, or other media files. They can contain some machine-readable data such
as the contact information of a person, the details of a calendar event,
a move in a chess game, etcetera.

Alice decides to share one file with only Bob, and keep it invisible
for the others. What are the steps through which she can achieve this,
depending on the capabilities of her (the sender's) server and Bob's
(the recipient's) server?

2. Initiate sharing process

To initiate the process of sharing a document from her server with
Bob, Alice connects to her server with her web browser, providing some
credentials (how she provides these is out of scope). She navigates the
web interface of her server to select the document she wants to send to
Bob.

Alice clicks or gestures her 'Share' intent for the document in some
way. The software application may have the capacity to act as a
[MICROPUB] client, in which case at this point Alice would also specify
the MicroPub endpoint to use.

3. Recipient selection

Alice may have an addressbook on her server where she stores the
identities and contact methods of people she knows. She may be able
to select Bob from this addressbook using the same or another web
interface. She may also have such an addressbook on her own client
device, or for instance on paper. Or maybe she knows an identifier for
Bob by heart. If Bob or someone else has published some of his contact
information, she may use a search application to find out identifiers
by which Bob can be contacted, which she can then use directly, and
possibly also store in her addressbook for future reference.

It is also possible that she remembers or looks up a web page describing
how to contact Bob, and discovers a usable identifier this way. An
addressbook application may also be able to infer identifiers for
various contact methods from such a web page programmatically.

Other methods for discovering a contact method and identifier for Bob
may rely on Alice knowing that Bob is a friend of Cindy, and she may
search a list of friends of Cindy named Bob, to confirm whether the
intended Bob is listed there. Similarly, she may remember that Bob is
for instance a member of her rowing club, and search a directory of
members of that rowing club to locate contact information about him.
Again, such an inference may be helped by a software application which
is capable of infering such friend-of-a-friend relationships.

Finally, Alice may have a contact identifier for Bob which she knows
will allow her to communicate with him, but not to share the document
with him. She may for instance contact Bob by telephone or irc to ask
him for his email address.
    
4. Recipient notification

Depending on the contact methods for which Alice has discovered Bob's
identifier in the recipient selection step, she may complete the
document sharing process by sending either the document data to Bob, or
a notification which contains machine-readable and/or human-readable
instructions for retrieving the document. For instance, she may send the
document as an email attachment, or send an email message that contains
a hyperlink or URL through which Bob may access the document.

In the case of sending the entire document directly, it will be helpful
to include some metadata about the document encoding. In the absence of
this, the software application that Bob uses to visualize the received
document may try to guess the encoding and media type of the document,
for instance by analyzing its first few bytes of data.

In the case of sending only the information needed to access the
document, but not the document itself, the necessary identifiers and
credentials for accessing the document may be given in natural language,
accompanied by human-readable instructions like 'You can download the
document at the following URL: ..., using the following password: ...'.

The notification may also contain information about how Bob can comment
on the document, or propose changes. Sometimes this information may be
implied by the notification method, or become obvious when Bob access
the document. For instance, Alice may send the URL of a web page which
contains a 'Comment' or 'Edit' button, inviting Bob to comment or
propose changes to the document using that web page. These comments
proposed changes may then either be applied and displayed immediately,
or the web application may allow Alice to review them before they are
applied and displayed.

One protocol for notifying recipients is [WEBMENTION]. This is a
recent successor of the older [PINGBACK], [REFBACK], and [TRACKBACK]
protocols. WebMention is primarily intended for sending comments
on existing documents, and not for initially sharing a document in
the first place, nor for proposing edits. But by "commenting" on a
recipient's main identifying URL (home page), it could also be used to
send a document that is not a comment on any existing document. Also, as
WebMention comments are often formatted as machine-readable documents
using [MICROFORMATS], a 'proposed-edit' comment type could be defined,
by which Bob's server may communicate Bob's proposed edits to Alice's
server in a machine-readable way. The authors intend to research both
these possible extensions to the WebMention protocol.

The software application may allow Alice to select the method by which
to notify Bob, or select a reasonable default. Bob may also publish
machine-readable preferences indicating how Bob prefers to receive
documents that are shared with him.

The notification may also include human-readable information about which
types of feedback are invited from Bob. For instance, Alice may share a
document which contains a collection of photos, and Bob may be invited
to add photos to this collection, but not delete any of the existing
ones. The authors intend to research ways of adding such feedback
invitations in a machine-readable way, for instance to a WebMention
notification.

Note that inviting certain types of feedback does not necessarily imply
that Alice's server will automatically accept, apply, and display such
feedback. Alice may want to review all proposed changes before applying
them, and review all comments before displaying them.

The notification may include all necessary credentials for accessing
the resource, in which case it is important for the software on Bob's
server not to display such a notification publically, as this would
lead to accidentally publishing a privately shared document publically.
Alternatively, the authentication step may be delayed until Bob, or
software running on Bob's server, actually accesses the document.
    
The software that Alice uses to send the notification to Bob may use
a concept of roles, which summarize which types of feedback Bob will
be invited to reply with. For instance, she may select a 'contributor'
role to invite Bob to send back only comments and additions, or
an 'admin' role inviting Bob to propose any kind of change to the
document, including deletions. We consider such roles mainly a matter of
interaction between Alice and the software she uses.

5. Human access

Whichever the way of sending the notification, it SHOULD contain a URL
for Bob to open with a browser to view and/or download the document from
what we call an access page.

The notification MAY include a password or other type of secret
which Bob needs to paste or type into the web page. The web page
located at the URL from the notification MAY also allow Bob to
authenticate with other methods if Alice can reasonably assume
Bob will have the ability to use those. Examples of such methods
are [OPENID], [INDIEAUTH], [INDIECERT], [PERSONA], [WEBID-TLS],
[WEBID-RSA](https://github.com/linkeddata/SoLiD#webid-rsa). It MAY allow
Bob to authenticate by proving he can receive a secret sent to him via
mobile telephone short messaging service (SMS) or email. It MAY also
allow Bob to authenticate using third-party identity providers like
social network sites.

Some of these methods of authentication rely on Alice to provide the
correct identifier(s) for Bob in the recipient selection step. These
identifier(s) are not necessarily equal to the identifier used for
sending the notification. For instance, if Alice knows both Bob's
WebMention end-point and his mobile phone number, she may send the
notification to Bob's WebMention endpoint, but allow Bob to authenticate
via SMS while accessing the document.

The relationship between Bob's identifiers in different identity systems
may in some cases be discovered programmatically, for instance with
[REL-ME] links on the main (index) web page, or [WELL-KNOWN] resources,
for Bob's personal DNS domain name.

The list of authentication methods Bob is offered will be limited by
the capabilities of the software that displays the access page for
the document. If this software is integrated with Alice's addressbook
software, then the addressbook entry for Bob may also be updated with
the authentication methods for which Alice provided the identifier,
those which were discovered programmatically during the process, and the
one that Bob uiltimately used to authenticate.

The access page MAY also give human-readable instructions to Bob, like
"please don't share this document publically", "please don't share
outside our Petanque team", or "please discard after reading, or after
30 days". Whether or not Bob follows such instructions is out of scope.
 
6. Machine access 
 
Some software applications are able to retrieve a document with
[UNATTENDED-INDIEAUTH] in reaction to a WebMention notification.
Although the [SoliD](https://github.com/linkeddata/SoLiD) platform does
not describe how to send or receive a document sharing notification,
it does describe how an application can use WebID-TLS or WebID-RSA to
authenticate programmatically to retrieve a document of whose existence
it is aware.

If the URL of the access page contains the secret
[capabilities](http://www.w3.org/TR/capability-urls/ ) then an
application can also access the document without human intervention.

If an application or human attempts to access the document without
sufficient credentials, a 410 http response code can be sent, together
with a WWW-Authenticate header hinting to a proposed authentication
method.
 
7. Publishing edits
 
After Alice has shared a document with Bob, if she did not send it
directly as for instance an email attachment, she may still edit its
contents between the time of sending the notification, and the first
time Bob access the document through the human-readable access page, or
a software application access the document on Bob's behalf.

But even once Bob, or software on his behalf, has accessed the document
for the first time, Alice may want to change its contents. For instance,
Alice may share her calendar with Bob, and keep editing her calendar
afterwards.

If she does this, she may send Bob a new notification, inviting him to
access the document again, to see the changed version. Another way of
publishing new versions of a same documents would be for Alice might
publish an [RSS] feed, an [ATOM] feed, or a [COUCHDB] changes feed
instead of the document itself.

Alternatively, the document could contain a reference to a feed of
its change history, for instance using a hyperlink in case of a HTML
document. A software application accessing the document on Bob's behalf
could discover this reference programmatically and keep polling the
change feed each time Bob views the document, apply Alice's changes, and
possibly provide a way for Bob to view its change history.

The approach where Alice's application sends a new notification to Bob's
application is more efficient if changes are rare, because it does
not require Bob's application to retrieve the change feed many times
(polling). The [PUBSUBHUBBUB] protocol could also be used as a way to
avoid unnecessary polling of change feeds.

The change feeds could concern one document, or aggregate changes in all
changes Alice ever shared with Bob into one feed.
The MicroPub protocol also supports updating
documents that have already been published
[MICROPUB-UPDATES](http://indiewebcamp.com/wiki/index.php?title=Micropub
&oldid=19338#Update ), so the application Alice uses to update the
document could send a MicroPub Update to the application which handles
the sharing of the document.

There are also situations where Bob can be expected not to make any
copies of the original document version, retrieving it always directly
from Alice's server when needed, and Bob may be more interested in
always retrieving the latest version, instead of being notified about
changes when they happen. An example could be when the document contains
an [OEMBED](http://www.oembed.com/#section7) data snippet, which Bob
embeds in another document by reference. This also means Bob will no
longer to access the document if Alice revokes his access to it, or
stops publishing the document at its URL.
 
8. Comments and write access
 
Regardless of whether or not Alice has invited him to do so in the
notification or in the access page, Bob may send reactions, like
comments, answers, additions, or proposed changes to Alice. He may send
Alice a notification for each reaction, a reference to a change feed,
for Alice's server application to poll.
 
It is up to Alice's application to either display all of Bob's comments
and changes immediately, or for instance to only display additions and
not deletions. This MAY be signalled in the notification and/or in the
access page (see above), so that Bob knows whether he effectively has
"write access" or "read-only access" to the document or not.
   
Alice's server may immediately apply Bob's changes (depending possibly
on the type of change) without Alice's intervention. If there were
multiple recipients, then maybe some recipients have permission to edit
(i.e., changes they propose will always be applied), and others only to
view (i.e., when they send a proposed change, it is not applied, or is
only applied after Alice reviewed and approved it.
  
This means that Alice can keep modifying the resource after sending it,
and Bob can also send modifications back to Alice. If Bob's application
retrieved a copy of the document and becomes aware of changes to it made
or approved by Alice, it SHOULD display such changes automatically,
possibly with a way to browse the change history. Alice's application
MAY display the document to Alice in its latest version with all its
approved changes (regardless of who proposed those changes), or display
both the version she shared and the modifications proposed by Bob
side-by-side.

["The change feed method has to be the same to guarantee the
synchronization." -> why? -Michiel]

We will now consider the case where Alice sent the message to possibly
more than one recipient, and the document may at any point contain
changes proposed by any of these recipients (either accepted immediately
by Alice's application, or reviewed and approved by Alice). When Alice's
change feed contains changes initiated by one of the recipients, it
SHOULD refer back to the URL where this change was originally proposed
by the recipient in question. This will allow the application of a
recipient to programmatically compare the "master" change feed published
by Alice with the list of changes proposed by that recipient itself.
This is a common pattern in [GIT] versioning, where branches can be
merged into a master branch, retaining the information about the
individual changes (commits).

If Bob reacts with a comment or a change proposal, he should somehow
notify Alice of this. WebMention was intended to do exactly this,
for comments on a publically published document. It is common for
applications to display (links to) all comments on a document on its
public access page. This practice may lead to [LINK-SPAM] when applied
to public documents, and when applied to privately shared documents, it
may result in accidentally publishing a private comment to the other
recipients of that shared document.

Bob MAY also send proposed changes to Alice over http, using a verb
like PUT or PATCH. This practice is used in [READ-WRITE-WEB] and
[COUCHDB], among others. Such http requests SHOULD be responded to with
a http response status that indicates whether the change request was
successful, accepted to be reviewed, or rejected.

A third practice for sending change proposals are git pull requests,
which would traditionally be sent to Alice by pgp-signed email, with the
patch in an attachment.

The authors intend to research whether we could define a way to mark up
change proposals in microformats, for Bob to post an updated version
and notify this to Alice. For instance, if Alice published a document
containing an h-entry of type photo-album, then a reaction to this could
be of type addition, and refer to a photo which Bob wants to be added to
that photo album. The same pattern could serve for adding events to a
calendar, or adding files in a document which represents a file system
directory.

Alice's application MAY be able to interpret changes to a document and
resolve the possible conflicts between them in certain cases (see also
the Data domains section below), or notify Alice and/or Bob that more
information is needed to resolve the conflict. A conflict occurs when
Alice and Bob both make changes in the document and arrive at different
new versions. In database theory this is called the optimistic lock
pattern: conflicts are tolerated, but the versions should eventually
converge and reach consistency. A pessimitic lock pattern would require
notifying all other actors with access to the document before starting
to make any changes to the current document version.
 
9. Real-time collaboration
 
If Alice and Bob are connected to the internet simultaneously, a
real-time conversation may be initated, for instance using [WEBRTC].
For instance, Alice might share a document with Bob which represents
a "phone call", after which an application on Bob's server may send a
[PUSH-NOTIFICATION] to Bob's (mobile) device, and when Bob gestures to
"pick up the phone", his server could react to Alice's "phone call" with
a document representing a WebRTC SessionDescriptionProtocol object. This
would allow rapid exchange of information back-and-forth between Alice
and Bob, for the duration of the real-time collaboration session.

Also, if Bob uses the access page to propose changes to the document,
and Alice is also connected to the internet at that time, the
interchange between Alice and Bob may be communicated between Alice's
server and her client device via [WEBSOCKETS]. This scenario could
be also be generalized to the situation where more than two people
are viewing, and possibly editing, the same document. To reduce the
information traffic that would need to pass through Alice's server,
these WebSockets could be used to establish WebRTC data channels between
each device, provided these devices support WebRTC, and that changes are
still submitted and ultimately committed to the dominant current version
of the document, on Alice's server.
 
10. Listing and revoking access
 
 * If Alice wants to share several documents with several people, she
should be able to maintain a list to exaclty know who has access to what
under which conditions.
 * The sharing history could show both what she shared in the past with
whom (and whether or not she invited them to send modifications back),
and whether the recipient has actually access or retrieved the resource.
It could also give Alice the option to revoke access
 * Alice but also Bob should be able to stop their servers automatically
applying edits whenever they want, After that, proposed edits from the
other party may still be displayed in a sort of moderation queue, or the
server could directy communicate failure/rejection of the edit/comment.
 * They should also be able to completely revoke the access and thus
cancelling the sharing

11. Data domains
 
 * If Bob accesses the resource with his browser, the presentation
can be tailored to how Bob as a human wants to consume the data. For
instance, multiple download/export formats may be offered using a web
view in a natural language Bob understands.
 * When Bob's server retrieves the resource, it may not be able to
discover its semantics, and therefore may not be able to add it to
Bob's server in a way that makes sense. For instance, if Bob's server
internally uses html documents, but Alice's server uses markdown
documents, a conversion may be necessary.
 * Data format hints can be provided using Content-Type headers, or some
linked data notation (microformats, json-ld, rdf, turtle, rdfa). This
can then point to a unique data type in some vocabulary.
 * But apart from notation format, there are many vocabularies (indeed,
see : https://www.w3.org/Social/track/issues/15 ). Sending for instance
a photo, a text document, a contact (description of a person), an blog
post or Activity, a comment, a git pull request, etc., will only work in
the desired way if both servers use the same vocabulary.
 * Our recommendation would be for the receiving server to support many
data format hint languages, as well as many vocabularies, as well as
many data formats and follow standards and w3c recommandations as much
as possible
*  Data domains are also important for automatic conflict resolution.

12. Security Considerations

13. IANA Considerations

    This document registers the 'remotestorage' link relation, as well
    as the following WebFinger properties:
      * "http://remotestorage.io/spec/version"
      * "http://tools.ietf.org/html/rfc6749#section-4.2"
      * "http://tools.ietf.org/html/rfc6750#section-2.3"
      * "http://tools.ietf.org/html/rfc7233"
      * "http://remotestorage.io/spec/web-authoring"

14. Acknowledgements

    The authors would like to thank everybody who contributed to the
    development of this protocol, including the IndieWeb and Social
    Web communities, the Decentralized Sharing Working Group, the
    participants in OuiShareLabsCamp 2015, as well as Alice and Bob
    themselves.

15. References

15.1. Normative References

    [WORDS]
        Bradner, S., "Key words for use in RFCs to Indicate Requirement
        Levels", BCP 14, RFC 2119, March 1997.

    [IRI]
        Duerst, M., "Internationalized Resource Identifiers (IRIs)",
        RFC 3987, January 2005.

    [WEBFINGER]
        Jones, P., Salguerio, G., Jones, M, and Smarr, J.,
        "WebFinger", RFC7033, September 2013.

    [OAUTH]
        "Section 4.2: Implicit Grant", in: Hardt, D. (ed), "The OAuth
        2.0 Authorization Framework", RFC6749, October 2012.

15.2. Informative References

    [HTTPS]
        Rescorla, E., "HTTP Over TLS", RFC2818, May 2000.

    [HTTP]
        Fielding et al., "Hypertext Transfer Protocol (HTTP/1.1):
        Semantics and Content", RFC7231, June 2014.

    [COND]
        Fielding et al., "Hypertext Transfer Protocol (HTTP/1.1):
        Conditional Requests", RFC7232, June 2014.

    [RANGE]
        Fielding et al., "Hypertext Transfer Protocol (HTTP/1.1):
        Conditional Requests", RFC7233, June 2014.

    [SPDY]
        Mark Belshe, Roberto Peon, "SPDY Protocol - Draft 3.1", http://
        www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1,
        September 2013.

    [JSON-LD]
        M. Sporny, G. Kellogg, M. Lanthaler, "JSON-LD 1.0", W3C
        Proposed Recommendation,
        http://www.w3.org/TR/2014/REC-json-ld-20140116/, January 2014.

    [CORS]
        van Kesteren, Anne (ed), "Cross-Origin Resource Sharing --
        W3C Candidate Recommendation 29 January 2013",
        http://www.w3.org/TR/cors/, January 2013.

    [MANIFEST]
        Mozilla Developer Network (ed), "App manifest -- Revision
        330541", https://developer.mozilla.org/en-
        US/Apps/Build/Manifest$revision/566677, April 2014.

    [DATASTORE]
        "WebAPI/DataStore", MozillaWiki, retrieved May 2014.
        https://wiki.mozilla.org/WebAPI/DataStore#Manifest

    [KERBEROS]
        C. Neuman et al., "The Kerberos Network Authentication Service
        (V5)", RFC4120, July 2005.

    [BEARER]
        M. Jones, D. Hardt, "The OAuth 2.0 Authorization Framework:
        Bearer Token Usage", RFC6750, October 2012.

    [AUTHORING]
        "Using remoteStorage for web authoring", reSite wiki, retrieved
        September 2014. https://github.com/michielbdejong/resite/wiki
        /Using-remoteStorage-for-web-authoring

16. Authors' addresses

    Michiel B. de Jong
    (independent)

    Email: michiel@michielbdejong.com


    Paul Tran-Van
    (Cozy Cloud)

    Email: paul@cozycloud.cc
