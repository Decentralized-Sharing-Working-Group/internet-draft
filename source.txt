INTERNET DRAFT                                      Michiel B. de Jong
Document: draft-dejong-decentralizedsharing-00           (independent)
                                                         Paul Tran-Van
Intended Status: Informational                            (Cozy Cloud)
Expires: ** December 2015                                  ** May 2015


                         Decentralized Sharing

Abstract

This draft describes the steps and challenges of sharing documents
between persons, using internet-connected servers. We
investigate the situation where a document exists on a server to which
the sender has access through some software application, but the
recipient(s) don't. All recipient(s) do,
however, have access to software applications that run on least one
other server. We discuss existing
and proposed methods for the sender to initiate the communication, for
each recipient to become aware of the sender's intent to share a
document, for each recipient to access the document directly, for the
document contents to be transmitted to server(s) to which the
recipient(s) have
access, for the sender to make and announce changes in the document
after it was initially sent, and for the recipient(s) to communicate
comments and proposed changes to the document back to the sender's
server. We
also discuss how semantics of the document may be communicated, and
how versioning conflicts may then
in some cases be resolved programmatically.
Given
that users of personal servers don't all run the same compatible
software on their server, the sending application needs to discover
which
application-level protocols are supported by the receiving application.


Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on ** December 2015.

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors. All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.
Table of Contents

   1. Introduction...................................................2
   2. Initiate sharing process.......................................2
   3. Recipient selection............................................2
   4. Recipient notification.........................................2
   5. Human access...................................................2
   6. Machine access ................................................2
   7. Publishing edits...............................................2
   8. Comments and write access......................................2
   9. Real-time collaboration........................................2
   10. Listing and revoking access...................................2
   11. Data domains..................................................2
   12. Security Considerations.......................................2
   13. IANA Considerations...........................................2
   14. Acknowledgements..............................................2
   15. References....................................................2
   15.1. Normative References........................................2
   15.2. Informative References......................................2
   16. Authors' addresses............................................2


1.  Introduction

There are several protocols for sending a document from one
server
to another. For instance, the sender may use an email
client to connect to her server via the [IMAP] protocol, or use a web
browser to connect to her server via the [HTTPS] protocol ("webmail"), to instruct
her server to forward an existing mail message from her server to one or
more recipients, identified by their email addresses, after which the
mailserver application running on her server can deliver the document to
the recipient's server using the [SMTP] protocol. The recipient may then
access the document from his server over the [POP], [IMAP], or [HTTPS]
protocol.

However, many software applications which people use nowadays to access
their documents, do not implement the SMTP, IMAP, or POP protocol (often due
to the complexity of dealing with email spam). Also, there is no commonly supported programmatic way
for the sender to update documents after they have been sent over
SMTP, nor for the recipient(s) to reply with proposed changes. Rather than proposing such a versioning protocol on top of SMTP,
we investigate how currently existing software applications implement
decentralized document sharing in practice, and where these common
practices could be improved and extended.

Some software applications allow sharing documents between users who
have access to the same server (we could call this centralized sharing),
and some also implement application-specific protocols that allow their
users to share documents with other users of the same software. This
leads to a dispersion of efforts between personal
server software projects.

Many software applications do allow sharing documents publically, for
instance by making them accessible over [HTTPS]. There are many ways to
restrict access to documents that are published that way, but this does
not solve the question of how recipient(s) get notified in the first
place that (and how) they have access to such a document.

There is no consensus yet on how to share documents privately over the
internet, in such a way that recipient(s) are notified, but other people
cannot retrieve the document, nor discover its existence.

This draft does not propose one universal solution, but rather
lists what puzzle pieces we are aware of, and what options may
exist to put them together. In general, we are interested in the case
where there may be more than one recipient, and where each recipient may have
access to more than one server (but not to the sender's server). But for
clarity of discussion we will at this point look at a simpler case.

We introduce Alice, who wants to share one document with Bob. Alice and Bob both
have a personal server, which they access to over a web interface, that's
to say, using a web browser that connects to their server over HTTPS. This interface
displays information in a human-readable way, and allows humans to
easily send commands using for instance their web browser's point-and-click gestures.

We assume there are multiple documents on Alice's server, and the web interface
visualizes these for her. We make no assumptions at this point about the
content of these documents; they can text, hypertext, sound, image,
or other media files, or contain some machine-readable data such as the
contact information of a person, the details of a calendar event, or a
move in a chess game, etcetera.

Alice decides to share one file with only Bob, and keep it invisible for
the others. What are the steps through which she can achieve this, depending on the
capabilities of her (the sender's) server and Bob's (the recipient's) server?

2. Initiate sharing process

* Alice picks a resource (web interface)
* Alice clicks or gestures 'Share' in some way (possibly specify
MicroPub endpoint, see also SoliD : https://github.com/linkeddata/SoLiD,
quite similar to Micropub - but doesn't seem to support notification)

3. Recipient selection

  * Her server might have an addressbook function, but that moves
discovery problem to how she adds Bob to it in the first place. If Bob's
not in there, she adds him just before selecting him.
  * What does she know about how to describe Bob?
    * friend of a friend
    * Full name, location, occupation, hobbies -> web search -> Bob's
homepage
    * email address
    * phone number
    * ...
    * Alice needs to know the Bob's server address
  * Roles (admin, contributor, read-only, etc.) may be used to invite
different interactions with different recipients
    
4. Recipient notification
 
 * Depends on contact method Alice knows for Bob (email, phone number,
WebMention, irc, Twitter, WhatsApp, ...)
  * Notification should contain:
    * A URL where Bob can access the resource
    * Possibly a separate secret for access
    * Possibly invite different types of feedbacks (comments, edits,
additions, ...)
    
    oEmbed?
    Is it useful to use the JSON data snippets from the providers of
existing services that use - http://www.oembed.com/#section7 in response
to recipient notifications?
    It could be really interesting, because in this case, the orginial
server with the original content is taking care of publishing this piece
of information.
    In our case of Bob sharing a picture with Alice, when Alice loads
the picture from her personal server, it will just load from Bob server.
    When Bob edit the picture, it will appear edited in Alice personal
server.
    If Alice wants to edit the picture, she could do it though this
interface also.
    Bob is in control of his picture. If he unplug his personal picture,
it is gone. Except if Alice develops a piece of software to keep a copy,
but this is an other debate.
 
5. Human access
 
 * Bob should be able to open the URL with a browser to view and/or
download the resource.
 * If a secret was included in the notification, he may be required to
paste that into the web view
 * Bob may be able to authenticate with
IndieAuth, IndieCert, Persona, OpenID, WebID-TLS,
[WebID-RSA](https://github.com/linkeddata/SoLiD#webid-rsa ), SMS- or
email verification, Twitter-, Facebook-, GitHub-, etc. Connect, or even
a basic password, which is the secret from the notification.
 * Bob could be offered a variety of these choices, possibly biased
towards the contact method used for the notification, or which
information Alice has about Bob (e.g. if Alice has Bob's email and
Twitter handle, then these two option could be at the top; if Alice
has Bob's homepage, her server could already scan if Bob's homepage
and /.well-known resources announce support for IndieAuth, IndieCert,
OpenID, and/or Persona). It also depends on the Alice's server
capabilities.
 * Alice's server may also automatically update the addressbook entry,
based on what it discovered.
 She may give instructions like "please don't share publically", or
"please share only within our Petanque team", or "Please destroy after
reading, or after 30 days". How Bob enforces those rules and how Alice
can trust him is probably not relevant here.
 
6. Machine access 
 
 * Some servers are able to retrieve a resource with unattended
IndieAuth in response to a WebMention
 * If the URL contains the secret
[capabilities](http://www.w3.org/TR/capability-urls/ ) then the server
can also access the resource without human intervention.
 * WebID-TLS and WebId-RSA could also be used server-to-server, in
reaction to a WWW-Authenticate header
 
7. Publishing edits
 
  * Alice might publish an rss, atom, or CouchDB changes feed instead of
a static document.
  * The resource could have a link to a feed of its change history.
 * Bob's server could discover and keep polling the change feed each
time Bob looks at the resource, and apply Alice's changes automatically.
  * Alice could also notify Bob each time she has edited the document.
Then Bob's server doesn't have to do polling.
  * The change feeds could concern one document or aggregates all of
them. An unique id for each document is then required, and a recipient
access control.
  * see
http://indiewebcamp.com/wiki/index.php?title=Micropub&oldid=19338#Update

 
8. Comments and write access
 
 * If Bob has write access to the document, and Alice publishes a change
feed, Bob could do the same. Then the document would be synchronized
between Alice and Bob servers .
 
   * It is up to Alice's server to either display Bob's comments and
changes automatically, or for instance only display additions and not
deletions. This should be signalled in the notification (see above), so
that Bob knows whether he has write access or not.
   
  * Alice's server may automatically apply Bob's changes (depending
possibly on the type of change) without Alice's intervention. If there
were multiple recipients, then maybe some recipients have permission to
edit, and others only to view.
  
 This means that Alice can keep modifying the resource after sending it,
and Bob can also send modifications back to Alice. Bob's server will
display Alice's changes automatically, possibly with a way to browse
the change history. Alice's server may do the same, or display both the
version she shared and the modifications proposed by Bob side-by-side.
 * The change feed method has to be the same to guarantee the
synchronization. So we need a way for Alice's feed to refer back to
Bob's feed to signal which edit merges which pull request, so to speak.
 * If Bob responds with a comment or an edit, he should somehow notify
Alice's server of this. For comments, WebMention does this. If Bob has
write access over http (read-write web, or create a CouchDB user for
Bob), he can simply send http requests which succeed or fail. Git pull
requests are traditionally sent by pgp-signed email, with the patch in
an attachment.
 * We could defne an 'edit' h-entry type in Micropub, for Bob to post
an updated version and notify this to Alice. If the h-entry is of
type photo-album, then a reply could be of type addition, and link to
an photo to be added to the photo album. Same for adding events to a
calendar or files in a directory.
  
 * Bob can send edits, for instance with http PUT or PATCH
 * git don't seem so appropriate for this. CouchDB replication could be
appropriate if it can be used without necessarly a CouchDB backend.

 * The system should be able to detect the conflicts and perhaps
solve them automatically (see also Data Domains below), or notify
Alice/Bob for manual resolution. A conflict occurs when Alice and Bob
do some changes at the same time on the same document and receive a
different new version. This is an optimistic lock vision from a database
perspective : conflicts are tolerated but the versions should converge
and reach consistency. A pessimitic lock would require to inform
recipients before modifying anything.

 
9. Real-time collaboration
 
* A WebRTC session may be negotiated if Bob and Alice are both online.
For instance, Alice might send Bob a "phone call", Bob's server
sends a push notification to Bob's phone, and when Bob picks up the
phone, his server responds to Alice's "phone call" with a WebRTC
SessionDescriptionProtocol object.
 
10. Listing and revoking access
 
 * If Alice wants to share several documents with several people, she
should be able to maintain a list to exaclty know who has access to what
under which conditions.
 * The sharing history could show both what she shared in the past with
whom (and whether or not she invited them to send modifications back),
and whether the recipient has actually access or retrieved the resource.
It could also give Alice the option to revoke access
 * Alice but also Bob should be able to stop their servers automatically
applying edits whenever they want, After that, proposed edits from the
other party may still be displayed in a sort of moderation queue, or the
server could directy communicate failure/rejection of the edit/comment.
 * They should also be able to completely revoke the access and thus
cancelling the sharing

11. Data domains
 
 * If Bob accesses the resource with his browser, the presentation
can be tailored to how Bob as a human wants to consume the data. For
instance, multiple download/export formats may be offered using a web
view in a natural language Bob understands.
 * When Bob's server retrieves the resource, it may not be able to
discover its semantics, and therefore may not be able to add it to
Bob's server in a way that makes sense. For instance, if Bob's server
internally uses html documents, but Alice's server uses markdown
documents, a conversion may be necessary.
 * Data format hints can be provided using Content-Type headers, or some
linked data notation (microformats, json-ld, rdf, turtle, rdfa). This
can then point to a unique data type in some vocabulary.
 * But apart from notation format, there are many vocabularies (indeed,
see : https://www.w3.org/Social/track/issues/15 ). Sending for instance
a photo, a text document, a contact (description of a person), an blog
post or Activity, a comment, a git pull request, etc., will only work in
the desired way if both servers use the same vocabulary.
 * Our recommendation would be for the receiving server to support many
data format hint languages, as well as many vocabularies, as well as
many data formats and follow standards and w3c recommandations as much
as possible
*  Data domains are also important for automatic conflict resolution.

12. Security Considerations

13. IANA Considerations

    This document registers the 'remotestorage' link relation, as well
    as the following WebFinger properties:
      * "http://remotestorage.io/spec/version"
      * "http://tools.ietf.org/html/rfc6749#section-4.2"
      * "http://tools.ietf.org/html/rfc6750#section-2.3"
      * "http://tools.ietf.org/html/rfc7233"
      * "http://remotestorage.io/spec/web-authoring"

14. Acknowledgements

    The authors would like to thank everybody who contributed to the
    development of this protocol, including the IndieWeb and Social
    Web communities, the Decentralized Sharing Working Group, the
    participants in OuiShareLabsCamp 2015, as well as Alice and Bob
    themselves.

15. References

15.1. Normative References

    [WORDS]
        Bradner, S., "Key words for use in RFCs to Indicate Requirement
        Levels", BCP 14, RFC 2119, March 1997.

    [IRI]
        Duerst, M., "Internationalized Resource Identifiers (IRIs)",
        RFC 3987, January 2005.

    [WEBFINGER]
        Jones, P., Salguerio, G., Jones, M, and Smarr, J.,
        "WebFinger", RFC7033, September 2013.

    [OAUTH]
        "Section 4.2: Implicit Grant", in: Hardt, D. (ed), "The OAuth
        2.0 Authorization Framework", RFC6749, October 2012.

15.2. Informative References

    [HTTPS]
        Rescorla, E., "HTTP Over TLS", RFC2818, May 2000.

    [HTTP]
        Fielding et al., "Hypertext Transfer Protocol (HTTP/1.1):
        Semantics and Content", RFC7231, June 2014.

    [COND]
        Fielding et al., "Hypertext Transfer Protocol (HTTP/1.1):
        Conditional Requests", RFC7232, June 2014.

    [RANGE]
        Fielding et al., "Hypertext Transfer Protocol (HTTP/1.1):
        Conditional Requests", RFC7233, June 2014.

    [SPDY]
        Mark Belshe, Roberto Peon, "SPDY Protocol - Draft 3.1", http://
        www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1,
        September 2013.

    [JSON-LD]
        M. Sporny, G. Kellogg, M. Lanthaler, "JSON-LD 1.0", W3C
        Proposed Recommendation,
        http://www.w3.org/TR/2014/REC-json-ld-20140116/, January 2014.

    [CORS]
        van Kesteren, Anne (ed), "Cross-Origin Resource Sharing --
        W3C Candidate Recommendation 29 January 2013",
        http://www.w3.org/TR/cors/, January 2013.

    [MANIFEST]
        Mozilla Developer Network (ed), "App manifest -- Revision
        330541", https://developer.mozilla.org/en-
        US/Apps/Build/Manifest$revision/566677, April 2014.

    [DATASTORE]
        "WebAPI/DataStore", MozillaWiki, retrieved May 2014.
        https://wiki.mozilla.org/WebAPI/DataStore#Manifest

    [KERBEROS]
        C. Neuman et al., "The Kerberos Network Authentication Service
        (V5)", RFC4120, July 2005.

    [BEARER]
        M. Jones, D. Hardt, "The OAuth 2.0 Authorization Framework:
        Bearer Token Usage", RFC6750, October 2012.

    [AUTHORING]
        "Using remoteStorage for web authoring", reSite wiki, retrieved
        September 2014. https://github.com/michielbdejong/resite/wiki
        /Using-remoteStorage-for-web-authoring

16. Authors' addresses

    Michiel B. de Jong
    (independent

    Email: michiel@michielbdejong.com


    Paul Tran-Van
    (Cozy Cloud)

    Email: paul@cozycloud.cc
