INTERNET DRAFT                                      Michiel B. de Jong
Document: draft-dejong-decentralizedsharing-00           (independent)
                                                         Paul Tran-Van
Intended Status: Informational                            (Cozy Cloud)
Expires: ** December 2015                                  ** May 2015


                         Decentralized Sharing

Abstract

This draft describes the steps and challenges of sharing documents
between persons, using internet-connected servers. We investigate the
situation where a document exists on a server to which the sender has
access through some software application, but the recipient(s) don't.
All recipient(s) do, however, have access to software applications that
run on least one other server.

We discuss existing and proposed methods for the sender to initiate the
communication, for each recipient to become aware of the sender's intent
to share a document, for each recipient to access the document directly,
for the document contents to be transmitted to server(s) to which the
recipient(s) have access, for the sender to make and announce changes in
the document after it was initially sent, and for the recipient(s) to
communicate comments and proposed changes to the document back to the
sender's server.

We also discuss how semantics of the document may be communicated,
and how versioning conflicts may then in some cases be resolved
programmatically. Given that users of personal servers don't all run
the same compatible software on their server, the sending application
needs to discover which application-level protocols are supported by the
receiving application.


Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on ** December 2015.


Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors. All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.


Table of Contents

   1. Introduction...................................................3
   2. Initiate sharing process.......................................4
   3. Recipient selection............................................5
   4. Recipient notification.........................................5
   5. Human access...................................................7
   6. Machine access ................................................*
   7. Publishing edits...............................................*
   8. Comments and write access......................................*
   9. Real-time collaboration........................................*
   10. Listing and revoking access...................................*
   11. Data domains..................................................*
   12. Security Considerations.......................................*
   13. IANA Considerations...........................................*
   14. Acknowledgements..............................................*
   15. References....................................................*
   15.1. Normative References........................................*
   15.2. Informative References......................................*
   16. Authors' addresses............................................*




1.  Introduction

When we say a sender 'shares' a document with some recipient(s),
we primarily mean the sender makes that document available for the
recipient(s) to consume, but not to others. Additionally, the sender
may send updated versions of the document after it was sent, and
recipient(s) may reply with comments and propose changes to the
document. The sender may decide to make such updates accessible to all
original recipient(s) or not. When we say 'document', we mean a string
of data which encodes some human-readable content in some data format.

There are several protocols for sending a document from one server to
another. For instance, the sender may use an email client to connect
to her server via the [IMAP] protocol, or use a web browser to connect
to her server via the [HTTPS] protocol ("webmail"), to instruct her
server to forward an existing mail message from her server to one or
more recipients, identified by their email addresses, after which the
mailserver application running on her server can deliver the document to
the recipient's server using the [SMTP] protocol. The recipient may then
access the document from his server over the [POP], [IMAP], or [HTTPS]
protocol.

However, many software applications which people use nowadays to access
their documents, do not implement the SMTP, IMAP, or POP protocol
(often due to the complexity of dealing with email spam). Also, there
is no commonly supported programmatic way for the sender to update
documents after they have been sent over SMTP, nor for the recipient(s)
to reply with proposed changes. Rather than proposing such a versioning
protocol on top of SMTP, we investigate how currently existing software
applications implement decentralized document sharing in practice, and
where these common practices could be improved and extended.

Some software applications allow sharing documents between users who
have access to the same server (we could call this centralized sharing),
and some also implement application-specific protocols that allow
their users to share documents with other users of the same software.
This leads to a dispersion of efforts between personal server software
projects.

Many software applications do allow sharing documents publically, for
instance by making them accessible over [HTTPS]. There are many ways to
restrict access to documents that are published that way, but this does
not solve the question of how recipient(s) get notified in the first
place that (and how) they have access to such a document.

There is no consensus yet on how to share documents privately over the
internet, in such a way that recipient(s) are notified, but other people
cannot retrieve the document, nor discover its existence.

This draft does not propose one universal solution, but rather lists
what puzzle pieces we are aware of, and what options may exist to put
them together. In general, we are interested in the case where there may
be more than one recipient, and where each recipient may have access to
more than one server (but not to the sender's server). But for clarity
of discussion we will at this point look at a simpler case.

We introduce Alice, who wants to share one document with Bob. Alice
and Bob both have a personal server, which they access to over a
web interface, that's to say, using a web browser that connects to
their server over HTTPS. This interface displays information in a
human-readable way, and allows humans to easily send commands using for
instance their web browser's point-and-click gestures.

We assume there are multiple documents on Alice's server, and the web
interface visualizes these for her. We make no assumptions at this point
about the content of these documents; they can text, hypertext, sound,
image, or other media files, or contain some machine-readable data such
as the contact information of a person, the details of a calendar event,
or a move in a chess game, etcetera.

Alice decides to share one file with only Bob, and keep it invisible
for the others. What are the steps through which she can achieve this,
depending on the capabilities of her (the sender's) server and Bob's
(the recipient's) server?

2. Initiate sharing process

To initiate the process of sharing a document from her server with
Bob, Alice connects to her server with her web browser, providing some
credentials (how she provides these is out of scope). She navigates the
web interface of her server to select the document she wants to send to
Bob.

Alice clicks or gestures her 'Share' intent for the document in some
way. The software application may have the capacity to act as a
[MICROPUB] client, in which case at this point Alice would also specify
the MicroPub endpoint to use.

3. Recipient selection

Alice may have an addressbook on her server where she stores the
identities and contact methods of people she knows. She may be able
to select Bob from this addressbook using the same or another web
interface. She may also have such an addressbook on her own client
device, or for instance on paper. Or maybe she knows an identifier for
Bob by heart. If Bob or someone else has published some of his contact
information, she may use a search application to find out identifiers
by which Bob can be contacted, which she can then use directly, and
possibly also store in her addressbook for future reference.

It is also possible that she remembers or looks up a web page describing
how to contact Bob, and discovers a usable identifier this way. An
addressbook application may also be able to infer identifiers for
various contact methods from such a web page programmatically.

Other methods for discovering a contact method and identifier for Bob
may rely on Alice knowing that Bob is a friend of Cindy, and she may
search a list of friends of Cindy named Bob, to confirm whether the
intended Bob is listed there. Similarly, she may remember that Bob is
for instance a member of her rowing club, and search a directory of
members of that rowing club to locate contact information about him.
Again, such an inference may be helped by a software application which
is capable of infering such friend-of-a-friend relationships.

Finally, Alice may have a contact identifier for Bob which she knows
will allow her to communicate with him, but not to share the document
with him. She may for instance contact Bob by telephone or irc to ask
him for his email address.
    
4. Recipient notification

Depending on the contact methods for which Alice has discovered Bob's
identifier in the recipient selection step, she may complete the
document sharing process by sending either the document data to Bob, or
a notification which contains machine-readable and/or human-readable
instructions for retrieving the document. For instance, she may send the
document as an email attachment, or send an email message that contains
a hyperlink or URL through which Bob may access the document.

In the case of sending the entire document directly, it will be helpful
to include some metadata about the document encoding. In the absence of
this, the software application that Bob uses to visualize the received
document may try to guess the encoding and media type of the document,
for instance by analyzing its first few bytes of data.

In the case of sending only the information needed to access the
document, but not the document itself, the necessary identifiers and
credentials for accessing the document may be given in natural language,
accompanied by human-readable instructions like 'You can download the
document at the following URL: ..., using the following password: ...'.

The notification may also contain information about how Bob can comment
on the document, or propose changes. Sometimes this information may be
implied by the notification method, or become obvious when Bob access
the document. For instance, Alice may send the URL of a web page which
contains a 'Comment' or 'Edit' button, inviting Bob to comment or
propose changes to the document using that web page. These comments
proposed changes may then either be applied and displayed immediately,
or the web application may allow Alice to review them before they are
applied and displayed.

One protocol for notifying recipients is [WEBMENTION]. This is a
recent successor of the older [PINGBACK], [REFBACK], and [TRACKBACK]
protocols. WebMention is primarily intended for sending comments
on existing documents, and not for initially sharing a document in
the first place, nor for proposing edits. But by "commenting" on a
recipient's main identifying URL (home page), it could also be used to
send a document that is not a comment on any existing document. Also, as
WebMention comments are often formatted as machine-readable documents
using [MICROFORMATS], a 'proposed-edit' comment type could be defined,
by which Bob's server may communicate Bob's proposed edits to Alice's
server in a machine-readable way. The authors intend to research both
these possible extensions to the WebMention protocol.

The software application may allow Alice to select the method by which
to notify Bob, or select a reasonable default. Bob may also publish
machine-readable preferences indicating how Bob prefers to receive
documents that are shared with him.

The notification may also include human-readable information about which
types of feedback are invited from Bob. For instance, Alice may share a
document which contains a collection of photos, and Bob may be invited
to add photos to this collection, but not delete any of the existing
ones. The authors intend to research ways of adding such feedback
invitations in a machine-readable way, for instance to a WebMention
notification.

Note that inviting certain types of feedback does not necessarily imply
that Alice's server will automatically accept, apply, and display such
feedback. Alice may want to review all proposed changes before applying
them, and review all comments before displaying them.

The notification may include all necessary credentials for accessing
the resource, in which case it is important for the software on Bob's
server not to display such a notification publically, as this would
lead to accidentally publishing a privately shared document publically.
Alternatively, the authentication step may be delayed until Bob, or
software running on Bob's server, actually accesses the document.
    
The software that Alice uses to send the notification to Bob may use
a concept of roles, which summarize which types of feedback Bob will
be invited to reply with. For instance, she may select a 'contributor'
role to invite Bob to send back only comments and additions, or
an 'admin' role inviting Bob to propose any kind of change to the
document, including deletions. We consider such roles mainly a matter of
interaction between Alice and the software she uses.

5. Human access

Whichever the way of sending the notification, it SHOULD contain a URL
for Bob to open with a browser to view and/or download the document from
what we call an access page.

The notification MAY include a password or other type of secret
which Bob needs to paste or type into the web page. The web page
located at the URL from the notification MAY also allow Bob to
authenticate with other methods if Alice can reasonably assume
Bob will have the ability to use those. Examples of such methods
are [OPENID], [INDIEAUTH], [INDIECERT], [PERSONA], [WEBID-TLS],
[WEBID-RSA](https://github.com/linkeddata/SoLiD#webid-rsa). It MAY allow
Bob to authenticate by proving he can receive a secret sent to him via
mobile telephone short messaging service (SMS) or email. It MAY also
allow Bob to authenticate using third-party identity providers like
social network sites.

Some of these methods of authentication rely on Alice to provide the
correct identifier(s) for Bob in the recipient selection step. These
identifier(s) are not necessarily equal to the identifier used for
sending the notification. For instance, if Alice knows both Bob's
WebMention end-point and his mobile phone number, she may send the
notification to Bob's WebMention endpoint, but allow Bob to authenticate
via SMS while accessing the document.

The relationship between Bob's identifiers in different identity systems
may in some cases be discovered programmatically, for instance with
[REL-ME] links on the main (index) web page, or [WELL-KNOWN] resources,
for Bob's personal DNS domain name.

The list of authentication methods Bob is offered will be limited by
the capabilities of the software that displays the access page for
the document. If this software is integrated with Alice's addressbook
software, then the addressbook entry for Bob may also be updated with
the authentication methods for which Alice provided the identifier,
those which were discovered programmatically during the process, and the
one that Bob uiltimately used to authenticate.

The access page MAY also give human-readable instructions to Bob, like
"please don't share this document publically", "please don't share
outside our Petanque team", or "please discard after reading, or after
30 days". Whether or not Bob follows such instructions is out of scope.
 
6. Machine access 
 
Some software applications are able to retrieve a document with
[UNATTENDED-INDIEAUTH] in reaction to a WebMention notification.
Although the [SoliD](https://github.com/linkeddata/SoLiD) platform does
not describe how to send or receive a document sharing notification,
it does describe how an application can use WebID-TLS or WebID-RSA to
authenticate programmatically to retrieve a document of whose existence
it is aware.

If the URL of the access page contains the secret
[capabilities](http://www.w3.org/TR/capability-urls/ ) then an
application can also access the document without human intervention.

If an application or human attempts to access the document without
sufficient credentials, a 410 http response code can be sent, together
with a WWW-Authenticate header hinting to a proposed authentication
method.
 
7. Publishing edits
 
  * Alice might publish an rss, atom, or CouchDB changes feed instead of
a static document.
  * The resource could have a link to a feed of its change history.
 * Bob's server could discover and keep polling the change feed each
time Bob looks at the resource, and apply Alice's changes automatically.
  * Alice could also notify Bob each time she has edited the document.
Then Bob's server doesn't have to do polling.
  * The change feeds could concern one document or aggregates all of
them. An unique id for each document is then required, and a recipient
access control.
  * see
http://indiewebcamp.com/wiki/index.php?title=Micropub&oldid=19338#Update

    oEmbed?
    Is it useful to use the JSON data snippets from the providers of
existing services that use - http://www.oembed.com/#section7 in response
to recipient notifications?
    It could be really interesting, because in this case, the orginial
server with the original content is taking care of publishing this piece
of information.
    In our case of Bob sharing a picture with Alice, when Alice loads
the picture from her personal server, it will just load from Bob server.
    When Bob edit the picture, it will appear edited in Alice personal
server.
    If Alice wants to edit the picture, she could do it though this
interface also.
    Bob is in control of his picture. If he unplug his personal picture,
it is gone. Except if Alice develops a piece of software to keep a copy,
but this is an other debate.
 
8. Comments and write access
 
 * If Bob has write access to the document, and Alice publishes a change
feed, Bob could do the same. Then the document would be synchronized
between Alice and Bob servers .
 
   * It is up to Alice's server to either display Bob's comments and
changes automatically, or for instance only display additions and not
deletions. This should be signalled in the notification (see above), so
that Bob knows whether he has write access or not.
   
  * Alice's server may automatically apply Bob's changes (depending
possibly on the type of change) without Alice's intervention. If there
were multiple recipients, then maybe some recipients have permission to
edit, and others only to view.
  
 This means that Alice can keep modifying the resource after sending it,
and Bob can also send modifications back to Alice. Bob's server will
display Alice's changes automatically, possibly with a way to browse
the change history. Alice's server may do the same, or display both the
version she shared and the modifications proposed by Bob side-by-side.
 * The change feed method has to be the same to guarantee the
synchronization. So we need a way for Alice's feed to refer back to
Bob's feed to signal which edit merges which pull request, so to speak.
 * If Bob responds with a comment or an edit, he should somehow notify
Alice's server of this. For comments, WebMention does this. If Bob has
write access over http (read-write web, or create a CouchDB user for
Bob), he can simply send http requests which succeed or fail. Git pull
requests are traditionally sent by pgp-signed email, with the patch in
an attachment.
 * We could defne an 'edit' h-entry type in Micropub, for Bob to post
an updated version and notify this to Alice. If the h-entry is of
type photo-album, then a reply could be of type addition, and link to
an photo to be added to the photo album. Same for adding events to a
calendar or files in a directory.
  
 * Bob can send edits, for instance with http PUT or PATCH
 * git don't seem so appropriate for this. CouchDB replication could be
appropriate if it can be used without necessarly a CouchDB backend.

 * The system should be able to detect the conflicts and perhaps
solve them automatically (see also Data Domains below), or notify
Alice/Bob for manual resolution. A conflict occurs when Alice and Bob
do some changes at the same time on the same document and receive a
different new version. This is an optimistic lock vision from a database
perspective : conflicts are tolerated but the versions should converge
and reach consistency. A pessimitic lock would require to inform
recipients before modifying anything.

 
9. Real-time collaboration
 
* A WebRTC session may be negotiated if Bob and Alice are both online.
For instance, Alice might send Bob a "phone call", Bob's server
sends a push notification to Bob's phone, and when Bob picks up the
phone, his server responds to Alice's "phone call" with a WebRTC
SessionDescriptionProtocol object.
 
10. Listing and revoking access
 
 * If Alice wants to share several documents with several people, she
should be able to maintain a list to exaclty know who has access to what
under which conditions.
 * The sharing history could show both what she shared in the past with
whom (and whether or not she invited them to send modifications back),
and whether the recipient has actually access or retrieved the resource.
It could also give Alice the option to revoke access
 * Alice but also Bob should be able to stop their servers automatically
applying edits whenever they want, After that, proposed edits from the
other party may still be displayed in a sort of moderation queue, or the
server could directy communicate failure/rejection of the edit/comment.
 * They should also be able to completely revoke the access and thus
cancelling the sharing

11. Data domains
 
 * If Bob accesses the resource with his browser, the presentation
can be tailored to how Bob as a human wants to consume the data. For
instance, multiple download/export formats may be offered using a web
view in a natural language Bob understands.
 * When Bob's server retrieves the resource, it may not be able to
discover its semantics, and therefore may not be able to add it to
Bob's server in a way that makes sense. For instance, if Bob's server
internally uses html documents, but Alice's server uses markdown
documents, a conversion may be necessary.
 * Data format hints can be provided using Content-Type headers, or some
linked data notation (microformats, json-ld, rdf, turtle, rdfa). This
can then point to a unique data type in some vocabulary.
 * But apart from notation format, there are many vocabularies (indeed,
see : https://www.w3.org/Social/track/issues/15 ). Sending for instance
a photo, a text document, a contact (description of a person), an blog
post or Activity, a comment, a git pull request, etc., will only work in
the desired way if both servers use the same vocabulary.
 * Our recommendation would be for the receiving server to support many
data format hint languages, as well as many vocabularies, as well as
many data formats and follow standards and w3c recommandations as much
as possible
*  Data domains are also important for automatic conflict resolution.

12. Security Considerations

13. IANA Considerations

    This document registers the 'remotestorage' link relation, as well
    as the following WebFinger properties:
      * "http://remotestorage.io/spec/version"
      * "http://tools.ietf.org/html/rfc6749#section-4.2"
      * "http://tools.ietf.org/html/rfc6750#section-2.3"
      * "http://tools.ietf.org/html/rfc7233"
      * "http://remotestorage.io/spec/web-authoring"

14. Acknowledgements

    The authors would like to thank everybody who contributed to the
    development of this protocol, including the IndieWeb and Social
    Web communities, the Decentralized Sharing Working Group, the
    participants in OuiShareLabsCamp 2015, as well as Alice and Bob
    themselves.

15. References

15.1. Normative References

    [WORDS]
        Bradner, S., "Key words for use in RFCs to Indicate Requirement
        Levels", BCP 14, RFC 2119, March 1997.

    [IRI]
        Duerst, M., "Internationalized Resource Identifiers (IRIs)",
        RFC 3987, January 2005.

    [WEBFINGER]
        Jones, P., Salguerio, G., Jones, M, and Smarr, J.,
        "WebFinger", RFC7033, September 2013.

    [OAUTH]
        "Section 4.2: Implicit Grant", in: Hardt, D. (ed), "The OAuth
        2.0 Authorization Framework", RFC6749, October 2012.

15.2. Informative References

    [HTTPS]
        Rescorla, E., "HTTP Over TLS", RFC2818, May 2000.

    [HTTP]
        Fielding et al., "Hypertext Transfer Protocol (HTTP/1.1):
        Semantics and Content", RFC7231, June 2014.

    [COND]
        Fielding et al., "Hypertext Transfer Protocol (HTTP/1.1):
        Conditional Requests", RFC7232, June 2014.

    [RANGE]
        Fielding et al., "Hypertext Transfer Protocol (HTTP/1.1):
        Conditional Requests", RFC7233, June 2014.

    [SPDY]
        Mark Belshe, Roberto Peon, "SPDY Protocol - Draft 3.1", http://
        www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1,
        September 2013.

    [JSON-LD]
        M. Sporny, G. Kellogg, M. Lanthaler, "JSON-LD 1.0", W3C
        Proposed Recommendation,
        http://www.w3.org/TR/2014/REC-json-ld-20140116/, January 2014.

    [CORS]
        van Kesteren, Anne (ed), "Cross-Origin Resource Sharing --
        W3C Candidate Recommendation 29 January 2013",
        http://www.w3.org/TR/cors/, January 2013.

    [MANIFEST]
        Mozilla Developer Network (ed), "App manifest -- Revision
        330541", https://developer.mozilla.org/en-
        US/Apps/Build/Manifest$revision/566677, April 2014.

    [DATASTORE]
        "WebAPI/DataStore", MozillaWiki, retrieved May 2014.
        https://wiki.mozilla.org/WebAPI/DataStore#Manifest

    [KERBEROS]
        C. Neuman et al., "The Kerberos Network Authentication Service
        (V5)", RFC4120, July 2005.

    [BEARER]
        M. Jones, D. Hardt, "The OAuth 2.0 Authorization Framework:
        Bearer Token Usage", RFC6750, October 2012.

    [AUTHORING]
        "Using remoteStorage for web authoring", reSite wiki, retrieved
        September 2014. https://github.com/michielbdejong/resite/wiki
        /Using-remoteStorage-for-web-authoring

16. Authors' addresses

    Michiel B. de Jong
    (independent

    Email: michiel@michielbdejong.com


    Paul Tran-Van
    (Cozy Cloud)

    Email: paul@cozycloud.cc
